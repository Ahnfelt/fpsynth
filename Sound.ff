sound(time: Float): Float {
    song(time)
    /*envelope(time - 1.0, 1.0, adsrEnvelope) {square(time, midiC(4))} +
    envelope(time - 2.0, 1.0, adsrEnvelope) {sawtooth(time, midiD(4))} +
    envelope(time - 3.0, 1.0, adsrEnvelope) {sine(time, midiE(4))}*/
}


// Song

song(time: Float): Float {
    0.5 * progressionIxVxvixIV(time, smoothToothInstrument) +
    0.5 * progressionvixIVxIxV(time - 4.0, smoothToothInstrument)
}

smoothToothInstrument(time: Float, duration: Float, frequency: Float): Float {
    envelope(time, duration, adsrEnvelope) {smoothTooth(time, frequency)}
}

progressionIxVxvixIV(time: Float, play: (Float, Float, Float) => Float): Float {
    play(time - 0.0, 0.5, midiC(4)) + play(time - 0.0, 0.5, midiE(4)) + play(time - 0.5, 0.5, midiG(4)) +
    play(time - 1.0, 0.5, midiB(3)) + play(time - 1.0, 0.5, midiD(4)) + play(time - 1.5, 0.5, midiG(4)) +
    play(time - 2.0, 0.5, midiC(4)) + play(time - 2.0, 0.5, midiE(4)) + play(time - 2.5, 0.5, midiA(4)) +
    play(time - 3.0, 0.5, midiC(4)) + play(time - 3.0, 0.5, midiF(4)) + play(time - 3.5, 0.5, midiA(4))
}

progressionvixIVxIxV(time: Float, play: (Float, Float, Float) => Float): Float {
    play(time - 0.0, 0.5, midiC(4)) + play(time - 0.0, 0.5, midiE(4)) + play(time - 0.5, 0.5, midiA(4)) +
    play(time - 1.0, 0.5, midiC(4)) + play(time - 1.0, 0.5, midiF(4)) + play(time - 1.5, 0.5, midiA(4)) +
    play(time - 2.0, 0.5, midiC(4)) + play(time - 2.0, 0.5, midiE(4)) + play(time - 2.5, 0.5, midiG(4)) +
    play(time - 3.0, 0.5, midiB(3)) + play(time - 3.0, 0.5, midiD(4)) + play(time - 3.5, 0.5, midiG(4))
}


// Waveforms

sine(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    phase.sin()
}

triangle(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    2 * (2 * (phase / (2 * Float.pi()) - (phase / (2 * Float.pi()) + 0.5).floor())).abs() - 1
}

square(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    phase.sin().sign()
}

sawtooth(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    2 * (phase / (2 * Float.pi()) - (phase / (2 * Float.pi()) + 0.5).floor())
}

smoothTooth(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    let newTime = time + phase.sin() / (frequency * 2 * Float.pi())
    let newPhase = newTime * frequency * 2 * Float.pi()
    newPhase.sin()
}

unison(
    waveform: (Float, Float) => Float
    time: Float
    frequency: Float
    voices: Int = 3
    detuneCents: Float = 5.0
    outputGain: Float = 0.7
): Float {
    let detuneFactor = pow(2.0, detuneCents / 1200.0)
    mutable output: Float = 0.0
    0.until(voices).each {voice =>
        let detuneDirection = if(voice % 2 == 0.0) {1.0} else {-1.0}
        let detunedFreq = frequency * pow(detuneFactor, detuneDirection * voice / (voices - 1))
        let phaseOffset = (voice / voices) * 2 * Float.pi()
        let phase = time * detunedFreq * 2 * Float.pi() + phaseOffset
        output += waveform(phase, detunedFreq)
    }
    (output / voices) * outputGain
}

// Envelopes

envelope(time: Float, duration: Float, envelope: (Float, Float) => Float, amplitude: () => Float): Float {
    if(time < 0.0 || time > duration) {0.0} else {
        amplitude() * envelope(time, duration)
    }
}

linearEnvelope(time: Float, duration: Float): Float {
    let half = duration / 2.0
    if(time < half) {
        time / half
    } else {
        1.0 - (time - half) / half
    }
}

adsrEnvelope(
    time: Float
    duration: Float
    attack: Float = 0.1
    decay: Float = 0.2
    sustain: Float = 0.5
    release: Float = 0.2
    sustainLevel: Float = 0.7
): Float {
    let attackTime = attack * duration
    let decayTime = decay * duration
    let releaseTime = release * duration
    let sustainEnd = duration - releaseTime
    if(time < attackTime) {
        time / attackTime
    } elseIf {time < attackTime + decayTime} {
        1.0 - (1.0 - sustainLevel) * (time - attackTime) / decayTime
    } elseIf {time < sustainEnd} {
        sustainLevel
    } else {
        sustainLevel * (1.0 - (time - sustainEnd) / releaseTime)
    }
}


// Notes (computed according to the MIDI standard)

midiC(octave: Int): Float {
    midiNote(octave, 0.0)
}

midiCs(octave: Int): Float {
    midiNote(octave, 1.0)
}

midiDb(octave: Int): Float {
    midiCs(octave)
}

midiD(octave: Int): Float {
    midiNote(octave, 2.0)
}

midiDs(octave: Int): Float {
    midiNote(octave, 3.0)
}

midiEb(octave: Int): Float {
    midiDs(octave)
}

midiE(octave: Int): Float {
    midiNote(octave, 4.0)
}

midiF(octave: Int): Float {
    midiNote(octave, 5.0)
}

midiFs(octave: Int): Float {
    midiNote(octave, 6.0)
}

midiGb(octave: Int): Float {
    midiFs(octave)
}

midiG(octave: Int): Float {
    midiNote(octave, 7.0)
}

midiGs(octave: Int): Float {
    midiNote(octave, 8.0)
}

midiAb(octave: Int): Float {
    midiGs(octave)
}

midiA(octave: Int): Float {
    midiNote(octave, 9.0)
}

midiAs(octave: Int): Float {
    midiNote(octave, 10.0)
}

midiBb(octave: Int): Float {
    midiAs(octave)
}

midiB(octave: Int): Float {
    midiNote(octave, 11.0)
}

midiNote(octave: Int, semitone: Float): Float {
    // A4 is 440 Hz, also known as pitch standard
    // Going up an octave (e.g. A4 to A5) doubles the frequency
    let note = 12 * (octave + 1) + semitone
    440.0 * pow(2.0, ((note - 69) / 12))
}


// Utility functions

pow(base: Float, exponent: Float): Float {
    Js->Math->pow(base, exponent)?
}
