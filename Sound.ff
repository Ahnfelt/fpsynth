sound(time: Float): Float {
    song(time)
}


// Song

song(time: Float): Float {
    echo(0.3, time) {time =>
        0.5 * progressionIxVxvixIV(time, smoothToothInstrument) +
        0.5 * progressionvixIVxIxV(time - 4.0, smoothToothInstrument)
    } + 
    0.8 * snarePattern(time)
    //0.5 * progressionBase(time, bassInstrument)
}

smoothToothInstrument(time: Float, duration: Float, frequency: Float): Float {
    adsrEnvelope(time, duration, amplitude = {
        //harmonic(time) {time =>
            //vibrato(time, frequency, waveform = smoothTooth)
            smoothTooth(time, frequency)
        //}
    })
}

bassInstrument(time: Float, duration: Float, frequency: Float): Float {
    adsrEnvelope(time, duration, attack = 0.02, decay = 0.2, sustain = 0.25, release = 0.2) {
        softClip(time) {time =>
            harmonic(time) {time =>
                harmonic(time) {time =>
                    smoothTooth(time, frequency) + sine(time, frequency / 2)
                }
            }
        }
    }
}

progressionBase(time: Float, play: (Float, Float, Float) => Float): Float {
    function multi(time: Float, frequency: Float): Float {
        play(time - 0.25, 0.5, frequency) +
        play(time - 0.50, 0.5, frequency) +
        play(time - 0.75, 0.5, frequency)
    }
    multi(time - 0.0, midiC(3)) + 
    multi(time - 1.0, midiB(2)) + 
    multi(time - 2.0, midiC(3)) + 
    multi(time - 3.0, midiC(3)) + 
    multi(time - 4.0, midiC(3)) + 
    multi(time - 5.0, midiC(3)) + 
    multi(time - 6.0, midiC(3)) + 
    multi(time - 7.0, midiB(2))
}

progressionIxVxvixIV(time: Float, play: (Float, Float, Float) => Float): Float {
    play(time - 0.0, 0.5, midiC(4)) + 
        play(time - 0.0, 0.5, midiE(4)) + play(time - 0.5, 0.5, midiG(4)) +
    play(time - 1.0, 0.5, midiB(3)) + 
        play(time - 1.0, 0.5, midiD(4)) + play(time - 1.5, 0.5, midiG(4)) +
    play(time - 2.0, 0.5, midiC(4)) + 
        play(time - 2.0, 0.5, midiE(4)) + play(time - 2.5, 0.5, midiA(4)) +
    play(time - 3.0, 0.5, midiC(4)) + 
        play(time - 3.0, 0.5, midiF(4)) + play(time - 3.5, 0.5, midiA(4))
}

progressionvixIVxIxV(time: Float, play: (Float, Float, Float) => Float): Float {
    play(time - 0.0, 0.5, midiC(4)) + 
        play(time - 0.0, 0.5, midiE(4)) + play(time - 0.5, 0.5, midiA(4)) +
    play(time - 1.0, 0.5, midiC(4)) + 
        play(time - 1.0, 0.5, midiF(4)) + play(time - 1.5, 0.5, midiA(4)) +
    play(time - 2.0, 0.5, midiC(4)) + 
        play(time - 2.0, 0.5, midiE(4)) + play(time - 2.5, 0.5, midiG(4)) +
    play(time - 3.0, 0.5, midiB(3)) + 
        play(time - 3.0, 0.5, midiD(4)) + play(time - 3.5, 0.5, midiG(4))
}


// Drumms

snareInstrument(time: Float, duration: Float, frequency: Float): Float {

    function noise(time: Float): Float {
        Random.newFromFloat(time).nextFloat(-1.0, 1.0)
    }

    // Pitch envelope: starts at 3x frequency, drops down quickly
    let pitchEnv = 1.0 + 2.0 * (-time * 80.0).exp()

    // Body: short, pitch-falling sine wave
    let body = adsrEnvelope(
        time
        duration
        attack = 0.001
        decay = 0.07
        sustain = 0.0
        release = 0.05
        amplitude = {sine(time, frequency * pitchEnv)}
    )

    // Snare noise: classic noise burst
    let snare = adsrEnvelope(
        time
        duration
        attack = 0.0
        decay = 0.15
        sustain = 0.0
        release = 0.07
        amplitude = {noise(time)}
    )

    // Attack click: very short high-passed noise
    let click = adsrEnvelope(
        time
        duration = 0.02
        attack = 0.0
        decay = 0.02
        sustain = 0.0
        release = 0.01
        amplitude = {noise(time + 1)}
    )

    // Mix the layers
    0.6 * body + 0.8 * snare + 0.8 * click
}

snarePattern(time: Float): Float {
    snareInstrument(time - 1.0, 0.3, 200.0) + 
    snareInstrument(time - 3.0, 0.3, 200.0)
}

// Waveforms

sine(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    phase.sin()
}

triangle(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    2 * (2 * (phase / (2 * Float.pi()) - (phase / (2 * Float.pi()) + 0.5).floor())).abs() - 1
}

square(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    phase.sin().sign()
}

sawtooth(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    2 * (phase / (2 * Float.pi()) - (phase / (2 * Float.pi()) + 0.5).floor())
}

smoothTooth(time: Float, frequency: Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    let newTime = time + phase.sin() / (frequency * 2 * Float.pi())
    let newPhase = newTime * frequency * 2 * Float.pi()
    newPhase.sin()
}


// Effects

identity(time: Float, sound: Float => Float): Float {
    sound(time)
}

echo(delay: Float, time: Float, sound: Float => Float): Float {
    sound(time) + sound(time - delay) * 0.5 + sound(time - delay * 2) * 0.25
}

robot(time: Float, sound: Float => Float): Float {
    let phase = time * 100 * 2 * Float.pi()
    sound(time) * phase.sin()
}

harmonic(time: Float, sound: Float => Float): Float {
    sound(time) + 0.3 * sound(time * 2) + 0.1 * sound(time * 3)
}

pedal(distortion: Float, time: Float, sound: Float => Float): Float {
    (distortion * sound(time)).tanh()
}

hardClip(time: Float, sound: Float => Float): Float {
    (sound(time) * 1.5).clamp(-1.0, 1.0)
}

softClip(time: Float, sound: Float => Float): Float {
    let amplitude = sound(time)
    amplitude - (amplitude * amplitude * amplitude / 3)
}

soften(time: Float, sound: Float => Float): Float {
    (3 * sound(time)).atan() * 2 / Float.pi() 
}

tremolo(time: Float, frequency: Float = 8, sound: Float => Float): Float {
    let phase = time * frequency * 2 * Float.pi()
    sound(time) * (0.75 + 0.25 * phase.sin())
}

vibrato(
    time: Float
    frequency: Float
    depth: Float = 0.01
    rate: Float = 6.0
    waveform: (Float, Float) => Float
): Float {
    let mod = time * rate * 2 * Float.pi()
    let pitchBend = depth * mod.sin()
    let modulatedFreq = frequency * pow(2.0, pitchBend)
    waveform(time, modulatedFreq)
}

// Envelopes

adsrEnvelope(
    time: Float
    duration: Float
    attack: Float = 0.1
    decay: Float = 0.2
    sustain: Float = 0.7
    release: Float = 0.2
    amplitude: () => Float
): Float {
    if(time < 0.0) {
        0.0
    } elseIf {time < attack} {
        amplitude() * (time / attack)
    } elseIf {time < attack + decay} {
        amplitude() * (1.0 - (1.0 - sustain) * (time - attack) / decay)
    } elseIf {time < duration} {
        amplitude() * sustain
    } elseIf {time < duration + release} {
        amplitude() * sustain * (1.0 - (time - duration) / release)
    } else {
        0.0
    }
}


// Notes (computed according to the MIDI standard)

midiC(octave: Int): Float {
    midiNote(octave, 0.0)
}

midiCs(octave: Int): Float {
    midiNote(octave, 1.0)
}

midiDb(octave: Int): Float {
    midiCs(octave)
}

midiD(octave: Int): Float {
    midiNote(octave, 2.0)
}

midiDs(octave: Int): Float {
    midiNote(octave, 3.0)
}

midiEb(octave: Int): Float {
    midiDs(octave)
}

midiE(octave: Int): Float {
    midiNote(octave, 4.0)
}

midiF(octave: Int): Float {
    midiNote(octave, 5.0)
}

midiFs(octave: Int): Float {
    midiNote(octave, 6.0)
}

midiGb(octave: Int): Float {
    midiFs(octave)
}

midiG(octave: Int): Float {
    midiNote(octave, 7.0)
}

midiGs(octave: Int): Float {
    midiNote(octave, 8.0)
}

midiAb(octave: Int): Float {
    midiGs(octave)
}

midiA(octave: Int): Float {
    midiNote(octave, 9.0)
}

midiAs(octave: Int): Float {
    midiNote(octave, 10.0)
}

midiBb(octave: Int): Float {
    midiAs(octave)
}

midiB(octave: Int): Float {
    midiNote(octave, 11.0)
}

midiNote(octave: Int, semitone: Float): Float {
    // A4 is 440 Hz, also known as pitch standard
    // Going up an octave (e.g. A4 to A5) doubles the frequency
    let note = 12 * (octave + 1) + semitone
    440.0 * pow(2.0, ((note - 69) / 12))
}


// Utility functions

pow(base: Float, exponent: Float): Float {
    Js->Math->pow(base, exponent)?
}
